# Product Requirements Document (PRD)

**Project:** iWorkr Core Backend & Infrastructure  
**Version:** 1.0  
**Last Updated:** February 15, 2026  
**Status:** Draft  
**Tech Stack:** Supabase (Postgres, Auth, Edge Functions, Realtime, Storage), Polar.sh (Payments/MoR)

---

## 1. Executive Summary

The objective is to establish a robust, serverless backend foundation for iWorkr. This backend will handle Authentication, Multi-tenancy (Organization/Workspace support), and Subscription Management via Polar.sh. The architecture must be **modular**, allowing future feature sets (Jobs, CRM, Assets) to be plugged in as independent schema extensions without refactoring the core authentication or billing logic.

### Goals

1. **Zero-downtime auth** — Users authenticate via Supabase Auth (Google OAuth, Magic Link) and are automatically provisioned with a profile and default organization.
2. **Hard data isolation** — Every row in every functional table is scoped to an `organization_id`. Postgres RLS enforces this at the database level, not the application level.
3. **Billing as a service** — Polar.sh owns the merchant-of-record relationship. iWorkr never touches raw card data. Subscription state is cached locally for instant feature gating.
4. **Ship modules independently** — A new module (e.g., Fleet GPS) should be deployable with a single SQL migration and zero changes to auth, billing, or shell code.

### Non-Goals (v1.0)

- Native mobile app backends (push notifications, offline sync queues)
- Multi-region deployment
- Self-hosted / on-premise support
- White-label / reseller architecture

---

## 2. Architecture Principles

| # | Principle | Rationale |
|---|-----------|-----------|
| 1 | **Multi-Tenancy First** | Every functional table must have an `organization_id`. Data isolation is enforced strictly via Postgres Row Level Security (RLS). |
| 2 | **Polar.sh as Source of Truth (Billing)** | Subscription status, plan tiers, and payment failures are managed in Polar and synced to Supabase via Webhooks. The local `subscriptions` table is a read-cache, never the write-master. |
| 3 | **Modular Schema** | The database is divided into "Core" (Auth/Billing/Org) and "Modules" (Business Logic). Adding a module (e.g., "Fleet Management") should only require adding tables and RLS policies, not changing core auth code. |
| 4 | **Edge-Compute** | Heavy logic (emails, recurring tasks, complex aggregations, third-party API calls) runs on Supabase Edge Functions (Deno), not inside the client. Secrets never leave the server. |
| 5 | **Realtime by Default** | Any table where the UI shows live state (schedule blocks, inbox items, job status) has Supabase Realtime enabled. The client subscribes to filtered channels scoped by `organization_id`. |
| 6 | **Audit Everything** | All destructive or state-changing operations are logged to an `audit_log` table. This supports compliance (forms, finance) and debugging. |
| 7 | **Soft Deletes** | Critical business entities (jobs, clients, invoices) use `archived_at` timestamps instead of `DELETE`. Hard deletes are reserved for ephemeral data (notifications, stale invites). |

### System Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                      Next.js Frontend                       │
│            (App Router · React 19 · Zustand)                │
└──────────────┬──────────────────────┬───────────────────────┘
               │ supabase-js          │ REST / Realtime
               ▼                      ▼
┌──────────────────────────────────────────────────────────────┐
│                     Supabase Platform                        │
│  ┌──────────┐  ┌──────────┐  ┌───────────┐  ┌───────────┐  │
│  │  Auth     │  │ Postgres │  │  Edge Fn   │  │ Realtime  │  │
│  │ (GoTrue) │  │  + RLS   │  │  (Deno)    │  │ (WS)      │  │
│  └──────────┘  └──────────┘  └─────┬──────┘  └───────────┘  │
│  ┌──────────┐  ┌──────────┐        │                        │
│  │ Storage  │  │ pg_cron  │        │                        │
│  │ (S3)     │  │ pg_net   │        │                        │
│  └──────────┘  └──────────┘        │                        │
└────────────────────────────────────┼────────────────────────┘
                                     │ Webhooks
                                     ▼
                              ┌──────────────┐
                              │  Polar.sh    │
                              │  (Billing)   │
                              └──────────────┘
                              ┌──────────────┐
                              │  Resend      │
                              │  (Email)     │
                              └──────────────┘
```

---

## 3. Core Database Schema (The "Base")

All tables use `uuid` primary keys generated by `gen_random_uuid()`. All timestamps are `timestamptz` defaulting to `now()`.

### 3.1. Custom Types (Enums)

```sql
-- Core enums
create type public.org_role as enum (
  'owner', 'admin', 'manager', 'senior_tech',
  'technician', 'apprentice', 'subcontractor', 'office_admin'
);

create type public.invite_status as enum ('pending', 'accepted', 'expired');

create type public.subscription_status as enum (
  'active', 'past_due', 'canceled', 'incomplete', 'trialing'
);

-- Module enums (created with each module migration)
create type public.job_status as enum (
  'backlog', 'todo', 'in_progress', 'done', 'cancelled'
);

create type public.priority as enum (
  'urgent', 'high', 'medium', 'low', 'none'
);

create type public.client_status as enum (
  'active', 'lead', 'churned', 'inactive'
);

create type public.invoice_status as enum (
  'draft', 'sent', 'paid', 'overdue', 'voided'
);

create type public.schedule_block_status as enum (
  'scheduled', 'en_route', 'in_progress', 'complete'
);

create type public.asset_status as enum (
  'available', 'assigned', 'maintenance'
);

create type public.asset_category as enum (
  'vehicle', 'tool', 'equipment'
);

create type public.form_status as enum (
  'draft', 'published', 'archived'
);

create type public.submission_status as enum (
  'signed', 'pending', 'expired'
);

create type public.flow_status as enum (
  'active', 'paused', 'draft', 'archived'
);

create type public.integration_status as enum (
  'connected', 'disconnected', 'error', 'syncing'
);

create type public.member_status as enum (
  'active', 'pending', 'suspended', 'archived'
);
```

### 3.2. Authentication & Profiles

```sql
create table public.profiles (
  id              uuid primary key references auth.users on delete cascade,
  email           text not null,
  full_name       text,
  avatar_url      text,
  phone           text,
  timezone        text default 'UTC',
  notification_preferences jsonb default '{
    "email_digest": true,
    "push_jobs": true,
    "push_inbox": true,
    "push_schedule": true
  }'::jsonb,
  onboarding_completed boolean default false,
  created_at      timestamptz default now(),
  updated_at      timestamptz default now()
);

-- Index
create index idx_profiles_email on public.profiles (email);

-- Auto-create profile on signup
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = ''
as $$
begin
  insert into public.profiles (id, email, full_name, avatar_url)
  values (
    new.id,
    new.email,
    coalesce(new.raw_user_meta_data ->> 'full_name', new.raw_user_meta_data ->> 'name', split_part(new.email, '@', 1)),
    new.raw_user_meta_data ->> 'avatar_url'
  );
  return new;
end;
$$;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute function public.handle_new_user();

-- Auto-update updated_at
create or replace function public.update_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

create trigger set_profiles_updated_at
  before update on public.profiles
  for each row execute function public.update_updated_at();
```

### 3.3. Organizations (Workspaces)

```sql
create table public.organizations (
  id                uuid primary key default gen_random_uuid(),
  slug              text unique not null,
  name              text not null,
  trade             text,                     -- e.g., 'plumbing', 'electrical', 'hvac'
  logo_url          text,
  polar_customer_id text,                     -- Link to Polar.sh Customer object
  settings          jsonb default '{
    "timezone": "Australia/Brisbane",
    "currency": "AUD",
    "date_format": "DD/MM/YYYY",
    "fiscal_year_start": 7,
    "default_tax_rate": 10,
    "default_payment_terms": 14,
    "branches": ["HQ"]
  }'::jsonb,
  created_at        timestamptz default now(),
  updated_at        timestamptz default now()
);

-- Indexes
create unique index idx_organizations_slug on public.organizations (slug);
create index idx_organizations_polar on public.organizations (polar_customer_id)
  where polar_customer_id is not null;

-- Trigger
create trigger set_organizations_updated_at
  before update on public.organizations
  for each row execute function public.update_updated_at();
```

### 3.4. Organization Members (RBAC)

```sql
create table public.organization_members (
  organization_id uuid not null references public.organizations on delete cascade,
  user_id         uuid not null references public.profiles on delete cascade,
  role            public.org_role not null default 'technician',
  status          public.member_status not null default 'active',
  branch          text default 'HQ',
  skills          text[] default '{}',
  hourly_rate     numeric(10, 2),
  invited_by      uuid references public.profiles,
  joined_at       timestamptz default now(),

  primary key (organization_id, user_id)
);

-- Indexes
create index idx_org_members_user on public.organization_members (user_id);
create index idx_org_members_org on public.organization_members (organization_id);
create index idx_org_members_role on public.organization_members (organization_id, role);
```

### 3.5. Organization Invites

```sql
create table public.organization_invites (
  id              uuid primary key default gen_random_uuid(),
  organization_id uuid not null references public.organizations on delete cascade,
  email           text not null,
  role            public.org_role not null default 'technician',
  status          public.invite_status not null default 'pending',
  invited_by      uuid not null references public.profiles,
  token           text unique not null default encode(gen_random_bytes(32), 'hex'),
  expires_at      timestamptz not null default (now() + interval '7 days'),
  created_at      timestamptz default now(),

  unique (organization_id, email)
);

-- Index
create index idx_invites_token on public.organization_invites (token) where status = 'pending';
create index idx_invites_email on public.organization_invites (email);
```

### 3.6. Subscriptions (Synced from Polar)

```sql
create table public.subscriptions (
  id                     uuid primary key default gen_random_uuid(),
  organization_id        uuid not null references public.organizations on delete cascade,
  polar_subscription_id  text unique not null,
  polar_product_id       text,
  plan_key               text not null,       -- e.g., 'starter_monthly', 'pro_annual'
  status                 public.subscription_status not null default 'incomplete',
  current_period_start   timestamptz,
  current_period_end     timestamptz,
  cancel_at_period_end   boolean default false,
  canceled_at            timestamptz,
  metadata               jsonb default '{}',  -- Polar metadata passthrough
  created_at             timestamptz default now(),
  updated_at             timestamptz default now()
);

-- Indexes
create unique index idx_subscriptions_org on public.subscriptions (organization_id)
  where status in ('active', 'past_due', 'trialing');
create index idx_subscriptions_polar on public.subscriptions (polar_subscription_id);
create index idx_subscriptions_status on public.subscriptions (status);

-- Trigger
create trigger set_subscriptions_updated_at
  before update on public.subscriptions
  for each row execute function public.update_updated_at();
```

### 3.7. Audit Log

```sql
create table public.audit_log (
  id              uuid primary key default gen_random_uuid(),
  organization_id uuid references public.organizations on delete set null,
  user_id         uuid references public.profiles on delete set null,
  action          text not null,               -- e.g., 'job.created', 'invoice.sent', 'member.role_changed'
  entity_type     text not null,               -- e.g., 'job', 'invoice', 'organization_member'
  entity_id       text,                        -- The affected record's ID
  old_data        jsonb,                       -- Previous state (for updates)
  new_data        jsonb,                       -- New state
  ip_address      inet,
  user_agent      text,
  created_at      timestamptz default now()
);

-- Indexes (optimized for time-range queries per org)
create index idx_audit_log_org_time on public.audit_log (organization_id, created_at desc);
create index idx_audit_log_entity on public.audit_log (entity_type, entity_id);

-- Partition by month for performance (optional, depends on volume)
-- comment: Consider partitioning if audit_log exceeds 10M rows
```

---

## 4. Security & Row Level Security (RLS)

### 4.1. Helper Functions

```sql
-- Returns all organization IDs the authenticated user belongs to
create or replace function public.get_user_org_ids()
returns setof uuid
language sql
security definer
stable
as $$
  select organization_id
  from public.organization_members
  where user_id = auth.uid()
    and status = 'active';
$$;

-- Returns the user's role in a specific organization
create or replace function public.get_user_role(org_id uuid)
returns public.org_role
language sql
security definer
stable
as $$
  select role
  from public.organization_members
  where user_id = auth.uid()
    and organization_id = org_id
    and status = 'active';
$$;

-- Checks if user is at least the given role level in the org
create or replace function public.user_has_role(org_id uuid, min_role public.org_role)
returns boolean
language plpgsql
security definer
stable
as $$
declare
  role_order constant text[] := array[
    'owner', 'admin', 'manager', 'senior_tech',
    'technician', 'apprentice', 'subcontractor', 'office_admin'
  ];
  user_role public.org_role;
begin
  select role into user_role
  from public.organization_members
  where user_id = auth.uid()
    and organization_id = org_id
    and status = 'active';

  if user_role is null then return false; end if;

  return array_position(role_order, user_role::text)
      <= array_position(role_order, min_role::text);
end;
$$;

-- Checks if the current subscription is active (for feature gating)
create or replace function public.org_has_active_subscription(org_id uuid)
returns boolean
language sql
security definer
stable
as $$
  select exists (
    select 1 from public.subscriptions
    where organization_id = org_id
      and status in ('active', 'trialing')
      and current_period_end > now()
  );
$$;

-- Returns the plan key for an organization
create or replace function public.get_org_plan(org_id uuid)
returns text
language sql
security definer
stable
as $$
  select plan_key from public.subscriptions
  where organization_id = org_id
    and status in ('active', 'trialing')
  limit 1;
$$;
```

### 4.2. Core RLS Policies

```sql
-- ── Profiles ──────────────────────────────────────────
alter table public.profiles enable row level security;

create policy "Users can read own profile"
  on public.profiles for select
  using (id = auth.uid());

create policy "Users can update own profile"
  on public.profiles for update
  using (id = auth.uid())
  with check (id = auth.uid());

-- Members of the same org can see each other's profiles
create policy "Org members can read teammate profiles"
  on public.profiles for select
  using (
    id in (
      select om.user_id from public.organization_members om
      where om.organization_id in (select public.get_user_org_ids())
        and om.status = 'active'
    )
  );

-- ── Organizations ─────────────────────────────────────
alter table public.organizations enable row level security;

create policy "Members can read their orgs"
  on public.organizations for select
  using (id in (select public.get_user_org_ids()));

create policy "Owners/Admins can update their org"
  on public.organizations for update
  using (public.user_has_role(id, 'admin'))
  with check (public.user_has_role(id, 'admin'));

create policy "Authenticated users can create orgs"
  on public.organizations for insert
  with check (auth.uid() is not null);

-- ── Organization Members ──────────────────────────────
alter table public.organization_members enable row level security;

create policy "Members can read fellow members"
  on public.organization_members for select
  using (organization_id in (select public.get_user_org_ids()));

create policy "Admins+ can insert members"
  on public.organization_members for insert
  with check (public.user_has_role(organization_id, 'admin'));

create policy "Admins+ can update members"
  on public.organization_members for update
  using (public.user_has_role(organization_id, 'admin'));

create policy "Owners can delete members"
  on public.organization_members for delete
  using (public.user_has_role(organization_id, 'owner'));

-- ── Organization Invites ──────────────────────────────
alter table public.organization_invites enable row level security;

create policy "Members can view org invites"
  on public.organization_invites for select
  using (organization_id in (select public.get_user_org_ids()));

create policy "Admins+ can create invites"
  on public.organization_invites for insert
  with check (public.user_has_role(organization_id, 'admin'));

create policy "Invitees can view their own invites"
  on public.organization_invites for select
  using (email = (select email from auth.users where id = auth.uid()));

-- ── Subscriptions ─────────────────────────────────────
alter table public.subscriptions enable row level security;

create policy "Members can read their org subscription"
  on public.subscriptions for select
  using (organization_id in (select public.get_user_org_ids()));

-- Insert/Update only via service_role (webhook Edge Functions)
-- No insert/update policies for anon or authenticated roles

-- ── Audit Log ─────────────────────────────────────────
alter table public.audit_log enable row level security;

create policy "Admins+ can read audit log"
  on public.audit_log for select
  using (public.user_has_role(organization_id, 'admin'));

-- Insert via service_role or security definer functions only
```

---

## 5. Module Schemas

Each module follows the standard contract:

1. Every table has `organization_id uuid not null references organizations`
2. RLS is enabled with the org-membership policy
3. `created_at` / `updated_at` timestamps on every table
4. Soft deletes via `archived_at` where applicable
5. Realtime enabled where the UI needs live updates

### 5.1. Inbox Module

```sql
create table public.inbox_items (
  id                uuid primary key default gen_random_uuid(),
  organization_id   uuid not null references public.organizations on delete cascade,
  recipient_id      uuid not null references public.profiles,
  type              text not null check (type in (
    'job_assigned', 'quote_approved', 'mention', 'system', 'review'
  )),
  title             text not null,
  body              text,
  read              boolean default false,
  snoozed_until     timestamptz,
  archived          boolean default false,
  related_job_id    uuid,                     -- FK added when Jobs module exists
  related_client_id uuid,                     -- FK added when Clients module exists
  sender_id         uuid references public.profiles,
  created_at        timestamptz default now()
);

-- Indexes
create index idx_inbox_recipient on public.inbox_items (recipient_id, read, created_at desc);
create index idx_inbox_org on public.inbox_items (organization_id, created_at desc);

-- RLS
alter table public.inbox_items enable row level security;

create policy "Users can read their inbox"
  on public.inbox_items for select
  using (recipient_id = auth.uid() and organization_id in (select public.get_user_org_ids()));

create policy "Users can update their inbox items"
  on public.inbox_items for update
  using (recipient_id = auth.uid())
  with check (recipient_id = auth.uid());

-- Realtime
alter publication supabase_realtime add table public.inbox_items;
```

### 5.2. Jobs Module

```sql
create table public.jobs (
  id                uuid primary key default gen_random_uuid(),
  organization_id   uuid not null references public.organizations on delete cascade,
  title             text not null,
  description       text,
  status            public.job_status not null default 'backlog',
  priority          public.priority not null default 'none',
  client_id         uuid,                     -- FK to clients table
  assignee_id       uuid references public.profiles,
  location          text,
  location_coords   jsonb,                    -- { lat, lng }
  labels            text[] default '{}',
  due_date          timestamptz,
  estimated_hours   numeric(6, 2),
  actual_hours      numeric(6, 2),
  revenue           numeric(12, 2),
  cost              numeric(12, 2),
  created_by        uuid references public.profiles,
  archived_at       timestamptz,
  created_at        timestamptz default now(),
  updated_at        timestamptz default now()
);

create table public.job_subtasks (
  id          uuid primary key default gen_random_uuid(),
  job_id      uuid not null references public.jobs on delete cascade,
  title       text not null,
  completed   boolean default false,
  sort_order  integer default 0,
  created_at  timestamptz default now()
);

create table public.job_activity (
  id          uuid primary key default gen_random_uuid(),
  job_id      uuid not null references public.jobs on delete cascade,
  user_id     uuid references public.profiles,
  type        text not null check (type in (
    'status_change', 'comment', 'photo', 'invoice', 'creation', 'assignment'
  )),
  content     text,
  metadata    jsonb,                          -- photos[], old_status, new_status, etc.
  created_at  timestamptz default now()
);

-- Indexes
create index idx_jobs_org_status on public.jobs (organization_id, status) where archived_at is null;
create index idx_jobs_assignee on public.jobs (assignee_id, status) where archived_at is null;
create index idx_jobs_client on public.jobs (client_id) where archived_at is null;
create index idx_jobs_due on public.jobs (organization_id, due_date) where archived_at is null and status not in ('done', 'cancelled');
create index idx_job_subtasks_job on public.job_subtasks (job_id, sort_order);
create index idx_job_activity_job on public.job_activity (job_id, created_at desc);

-- RLS
alter table public.jobs enable row level security;
alter table public.job_subtasks enable row level security;
alter table public.job_activity enable row level security;

create policy "Members can read org jobs"
  on public.jobs for select
  using (organization_id in (select public.get_user_org_ids()));

create policy "Members can create jobs"
  on public.jobs for insert
  with check (organization_id in (select public.get_user_org_ids()));

create policy "Members can update jobs"
  on public.jobs for update
  using (organization_id in (select public.get_user_org_ids()));

create policy "Members can read subtasks"
  on public.job_subtasks for select
  using (job_id in (select id from public.jobs where organization_id in (select public.get_user_org_ids())));

create policy "Members can manage subtasks"
  on public.job_subtasks for all
  using (job_id in (select id from public.jobs where organization_id in (select public.get_user_org_ids())));

create policy "Members can read job activity"
  on public.job_activity for select
  using (job_id in (select id from public.jobs where organization_id in (select public.get_user_org_ids())));

create policy "Members can add job activity"
  on public.job_activity for insert
  with check (job_id in (select id from public.jobs where organization_id in (select public.get_user_org_ids())));

-- Triggers
create trigger set_jobs_updated_at
  before update on public.jobs
  for each row execute function public.update_updated_at();

-- Realtime
alter publication supabase_realtime add table public.jobs;
```

### 5.3. Clients Module

```sql
create table public.clients (
  id                uuid primary key default gen_random_uuid(),
  organization_id   uuid not null references public.organizations on delete cascade,
  name              text not null,
  email             text,
  phone             text,
  type              text check (type in ('residential', 'commercial')),
  status            public.client_status not null default 'lead',
  address           text,
  address_coords    jsonb,                    -- { lat, lng }
  tags              text[] default '{}',
  notes             text,
  since             timestamptz default now(),
  archived_at       timestamptz,
  created_at        timestamptz default now(),
  updated_at        timestamptz default now()
);

create table public.client_contacts (
  id          uuid primary key default gen_random_uuid(),
  client_id   uuid not null references public.clients on delete cascade,
  name        text not null,
  role        text,
  email       text,
  phone       text,
  is_primary  boolean default false,
  created_at  timestamptz default now()
);

create table public.client_activity (
  id          uuid primary key default gen_random_uuid(),
  client_id   uuid not null references public.clients on delete cascade,
  type        text not null check (type in (
    'job_completed', 'invoice_paid', 'invoice_sent', 'quote_sent',
    'note', 'job_created', 'call'
  )),
  content     text,
  amount      numeric(12, 2),
  related_job_id uuid,
  created_at  timestamptz default now()
);

-- Indexes
create index idx_clients_org on public.clients (organization_id, status) where archived_at is null;
create index idx_clients_email on public.clients (organization_id, email);
create index idx_client_contacts_client on public.client_contacts (client_id);
create index idx_client_activity_client on public.client_activity (client_id, created_at desc);

-- RLS
alter table public.clients enable row level security;
alter table public.client_contacts enable row level security;
alter table public.client_activity enable row level security;

create policy "Members can read org clients"
  on public.clients for select
  using (organization_id in (select public.get_user_org_ids()));

create policy "Members can manage clients"
  on public.clients for all
  using (organization_id in (select public.get_user_org_ids()));

create policy "Members can read client contacts"
  on public.client_contacts for select
  using (client_id in (select id from public.clients where organization_id in (select public.get_user_org_ids())));

create policy "Members can manage client contacts"
  on public.client_contacts for all
  using (client_id in (select id from public.clients where organization_id in (select public.get_user_org_ids())));

create policy "Members can read client activity"
  on public.client_activity for select
  using (client_id in (select id from public.clients where organization_id in (select public.get_user_org_ids())));

create policy "Members can add client activity"
  on public.client_activity for insert
  with check (client_id in (select id from public.clients where organization_id in (select public.get_user_org_ids())));

-- Triggers
create trigger set_clients_updated_at
  before update on public.clients
  for each row execute function public.update_updated_at();
```

### 5.4. Schedule Module

```sql
create table public.schedule_blocks (
  id                uuid primary key default gen_random_uuid(),
  organization_id   uuid not null references public.organizations on delete cascade,
  job_id            uuid references public.jobs on delete set null,
  technician_id     uuid not null references public.profiles,
  title             text not null,
  client_name       text,
  location          text,
  location_coords   jsonb,
  start_time        timestamptz not null,
  end_time          timestamptz not null,
  status            public.schedule_block_status not null default 'scheduled',
  travel_minutes    integer,
  conflict          boolean default false,
  notes             text,
  created_at        timestamptz default now(),
  updated_at        timestamptz default now(),

  constraint valid_time_range check (end_time > start_time)
);

-- Indexes
create index idx_schedule_org_time on public.schedule_blocks (organization_id, start_time, end_time);
create index idx_schedule_tech on public.schedule_blocks (technician_id, start_time);
create index idx_schedule_job on public.schedule_blocks (job_id) where job_id is not null;

-- RLS
alter table public.schedule_blocks enable row level security;

create policy "Members can read org schedule"
  on public.schedule_blocks for select
  using (organization_id in (select public.get_user_org_ids()));

create policy "Managers+ can manage schedule"
  on public.schedule_blocks for all
  using (public.user_has_role(organization_id, 'manager'));

create policy "Techs can update own block status"
  on public.schedule_blocks for update
  using (technician_id = auth.uid() and organization_id in (select public.get_user_org_ids()))
  with check (technician_id = auth.uid());

-- Triggers
create trigger set_schedule_blocks_updated_at
  before update on public.schedule_blocks
  for each row execute function public.update_updated_at();

-- Realtime (critical for Live Dispatch)
alter publication supabase_realtime add table public.schedule_blocks;
```

### 5.5. Finance Module

```sql
create table public.invoices (
  id                uuid primary key default gen_random_uuid(),
  organization_id   uuid not null references public.organizations on delete cascade,
  invoice_number    text not null,             -- e.g., 'INV-1250'
  client_id         uuid references public.clients,
  client_name       text not null,
  client_email      text,
  client_address    text,
  status            public.invoice_status not null default 'draft',
  issue_date        date not null default current_date,
  due_date          date not null,
  paid_date         date,
  subtotal          numeric(12, 2) not null default 0,
  tax_rate          numeric(5, 2) default 10,
  tax               numeric(12, 2) not null default 0,
  total             numeric(12, 2) not null default 0,
  payment_link      text,
  notes             text,
  related_job_id    uuid references public.jobs,
  created_by        uuid references public.profiles,
  archived_at       timestamptz,
  created_at        timestamptz default now(),
  updated_at        timestamptz default now(),

  unique (organization_id, invoice_number)
);

create table public.invoice_line_items (
  id          uuid primary key default gen_random_uuid(),
  invoice_id  uuid not null references public.invoices on delete cascade,
  description text not null,
  quantity    numeric(10, 2) not null default 1,
  unit_price  numeric(12, 2) not null,
  sort_order  integer default 0
);

create table public.invoice_events (
  id          uuid primary key default gen_random_uuid(),
  invoice_id  uuid not null references public.invoices on delete cascade,
  type        text not null check (type in (
    'created', 'sent', 'viewed', 'paid', 'voided', 'reminder'
  )),
  content     text,
  created_at  timestamptz default now()
);

create table public.payouts (
  id                uuid primary key default gen_random_uuid(),
  organization_id   uuid not null references public.organizations on delete cascade,
  amount            numeric(12, 2) not null,
  date              date not null,
  bank_account      text,
  status            text not null check (status in ('completed', 'pending', 'processing')),
  invoice_ids       uuid[] default '{}',
  created_at        timestamptz default now()
);

-- Indexes
create index idx_invoices_org on public.invoices (organization_id, status) where archived_at is null;
create index idx_invoices_client on public.invoices (client_id);
create index idx_invoices_due on public.invoices (organization_id, due_date)
  where status in ('sent', 'overdue') and archived_at is null;
create index idx_line_items_invoice on public.invoice_line_items (invoice_id, sort_order);
create index idx_invoice_events_invoice on public.invoice_events (invoice_id, created_at desc);
create index idx_payouts_org on public.payouts (organization_id, date desc);

-- RLS
alter table public.invoices enable row level security;
alter table public.invoice_line_items enable row level security;
alter table public.invoice_events enable row level security;
alter table public.payouts enable row level security;

create policy "Members can read org invoices"
  on public.invoices for select
  using (organization_id in (select public.get_user_org_ids()));

create policy "Admins+ can manage invoices"
  on public.invoices for all
  using (public.user_has_role(organization_id, 'admin'));

create policy "Members can read line items"
  on public.invoice_line_items for select
  using (invoice_id in (select id from public.invoices where organization_id in (select public.get_user_org_ids())));

create policy "Admins+ can manage line items"
  on public.invoice_line_items for all
  using (invoice_id in (select id from public.invoices where organization_id in (select public.get_user_org_ids())
    and public.user_has_role(organization_id, 'admin')));

create policy "Members can read invoice events"
  on public.invoice_events for select
  using (invoice_id in (select id from public.invoices where organization_id in (select public.get_user_org_ids())));

create policy "Members can read org payouts"
  on public.payouts for select
  using (organization_id in (select public.get_user_org_ids()));

-- Triggers
create trigger set_invoices_updated_at
  before update on public.invoices
  for each row execute function public.update_updated_at();

-- Auto-recalculate totals
create or replace function public.recalculate_invoice_totals()
returns trigger
language plpgsql
as $$
declare
  v_subtotal numeric;
  v_tax_rate numeric;
begin
  select coalesce(sum(quantity * unit_price), 0) into v_subtotal
  from public.invoice_line_items where invoice_id = coalesce(new.invoice_id, old.invoice_id);

  select tax_rate into v_tax_rate
  from public.invoices where id = coalesce(new.invoice_id, old.invoice_id);

  update public.invoices set
    subtotal = v_subtotal,
    tax = round(v_subtotal * v_tax_rate / 100, 2),
    total = v_subtotal + round(v_subtotal * v_tax_rate / 100, 2)
  where id = coalesce(new.invoice_id, old.invoice_id);

  return coalesce(new, old);
end;
$$;

create trigger recalc_invoice_on_line_change
  after insert or update or delete on public.invoice_line_items
  for each row execute function public.recalculate_invoice_totals();
```

### 5.6. Assets Module

```sql
create table public.assets (
  id                uuid primary key default gen_random_uuid(),
  organization_id   uuid not null references public.organizations on delete cascade,
  tag               text not null,             -- e.g., 'AST-001'
  name              text not null,
  category          public.asset_category not null,
  status            public.asset_status not null default 'available',
  assignee_id       uuid references public.profiles,
  image_url         text,
  serial_number     text,
  purchase_date     date,
  purchase_price    numeric(12, 2),
  depreciation_rate numeric(5, 2),             -- percent per year
  warranty_expiry   date,
  service_interval  integer,                   -- months
  last_service_date date,
  next_service_date date,
  location          text,
  location_coords   jsonb,
  notes             text,
  archived_at       timestamptz,
  created_at        timestamptz default now(),
  updated_at        timestamptz default now(),

  unique (organization_id, tag)
);

create table public.stock_items (
  id                uuid primary key default gen_random_uuid(),
  organization_id   uuid not null references public.organizations on delete cascade,
  sku               text not null,
  name              text not null,
  category          text,
  current_qty       integer not null default 0,
  max_qty           integer not null default 100,
  min_level         integer not null default 10,   -- reorder point
  unit_cost         numeric(10, 2),
  supplier          text,
  bin_location      text,
  last_restocked    timestamptz,
  created_at        timestamptz default now(),
  updated_at        timestamptz default now(),

  unique (organization_id, sku)
);

create table public.asset_audit_log (
  id                uuid primary key default gen_random_uuid(),
  organization_id   uuid not null references public.organizations on delete cascade,
  asset_id          uuid references public.assets on delete set null,
  asset_tag         text,
  type              text not null check (type in (
    'transfer', 'service', 'create', 'retire', 'stock_adjust'
  )),
  description       text,
  user_id           uuid references public.profiles,
  created_at        timestamptz default now()
);

-- Indexes
create index idx_assets_org on public.assets (organization_id, category, status) where archived_at is null;
create index idx_assets_assignee on public.assets (assignee_id) where assignee_id is not null;
create index idx_assets_service on public.assets (organization_id, next_service_date)
  where archived_at is null and next_service_date is not null;
create index idx_stock_org on public.stock_items (organization_id);
create index idx_stock_low on public.stock_items (organization_id)
  where current_qty <= min_level;
create index idx_asset_audit_org on public.asset_audit_log (organization_id, created_at desc);

-- RLS
alter table public.assets enable row level security;
alter table public.stock_items enable row level security;
alter table public.asset_audit_log enable row level security;

create policy "Members can read org assets"
  on public.assets for select
  using (organization_id in (select public.get_user_org_ids()));

create policy "Managers+ can manage assets"
  on public.assets for all
  using (public.user_has_role(organization_id, 'manager'));

create policy "Members can read stock items"
  on public.stock_items for select
  using (organization_id in (select public.get_user_org_ids()));

create policy "Managers+ can manage stock"
  on public.stock_items for all
  using (public.user_has_role(organization_id, 'manager'));

create policy "Members can read asset audit log"
  on public.asset_audit_log for select
  using (organization_id in (select public.get_user_org_ids()));

-- Triggers
create trigger set_assets_updated_at
  before update on public.assets
  for each row execute function public.update_updated_at();

create trigger set_stock_items_updated_at
  before update on public.stock_items
  for each row execute function public.update_updated_at();
```

### 5.7. Forms Module

```sql
create table public.form_templates (
  id                uuid primary key default gen_random_uuid(),
  organization_id   uuid not null references public.organizations on delete cascade,
  title             text not null,
  description       text,
  source            text not null check (source in ('custom', 'library')) default 'custom',
  status            public.form_status not null default 'draft',
  version           integer not null default 1,
  category          text,
  blocks            jsonb not null default '[]',   -- Array of FormBlock objects
  tags              text[] default '{}',
  verified          boolean default false,
  used_count        integer default 0,
  created_by        uuid references public.profiles,
  archived_at       timestamptz,
  created_at        timestamptz default now(),
  updated_at        timestamptz default now()
);

create table public.form_submissions (
  id                uuid primary key default gen_random_uuid(),
  organization_id   uuid not null references public.organizations on delete cascade,
  form_id           uuid not null references public.form_templates,
  form_version      integer not null,
  status            public.submission_status not null default 'pending',
  submitted_by      uuid references public.profiles,
  related_job_id    uuid references public.jobs,
  client_name       text,
  fields            jsonb not null default '[]',   -- Array of { label, value }
  telemetry         jsonb,                         -- IP, browser, OS, GPS, timestamp, SHA-256
  signed_at         timestamptz,
  expires_at        timestamptz,
  created_at        timestamptz default now()
);

-- Indexes
create index idx_forms_org on public.form_templates (organization_id, status) where archived_at is null;
create index idx_forms_source on public.form_templates (source, status) where archived_at is null;
create index idx_submissions_org on public.form_submissions (organization_id, created_at desc);
create index idx_submissions_form on public.form_submissions (form_id);
create index idx_submissions_job on public.form_submissions (related_job_id) where related_job_id is not null;

-- RLS
alter table public.form_templates enable row level security;
alter table public.form_submissions enable row level security;

create policy "Members can read org forms"
  on public.form_templates for select
  using (organization_id in (select public.get_user_org_ids()));

create policy "Admins+ can manage forms"
  on public.form_templates for all
  using (public.user_has_role(organization_id, 'admin'));

create policy "Members can read org submissions"
  on public.form_submissions for select
  using (organization_id in (select public.get_user_org_ids()));

create policy "Members can create submissions"
  on public.form_submissions for insert
  with check (organization_id in (select public.get_user_org_ids()));

-- Triggers
create trigger set_form_templates_updated_at
  before update on public.form_templates
  for each row execute function public.update_updated_at();
```

### 5.8. Automations Module

```sql
create table public.automation_flows (
  id                uuid primary key default gen_random_uuid(),
  organization_id   uuid not null references public.organizations on delete cascade,
  title             text not null,
  description       text,
  category          text not null check (category in ('marketing', 'billing', 'operations')),
  status            public.flow_status not null default 'draft',
  version           integer not null default 1,
  blocks            jsonb not null default '[]',   -- Array of FlowBlock objects
  metrics           jsonb default '{"runs_24h": 0, "success_rate": 100}',
  created_by        uuid references public.profiles,
  last_edited_by    uuid references public.profiles,
  archived_at       timestamptz,
  created_at        timestamptz default now(),
  updated_at        timestamptz default now()
);

create table public.automation_execution_logs (
  id                uuid primary key default gen_random_uuid(),
  organization_id   uuid not null references public.organizations on delete cascade,
  flow_id           uuid not null references public.automation_flows on delete cascade,
  trigger_source    text,
  status            text not null check (status in ('success', 'failed', 'skipped')),
  error_message     text,
  duration_ms       integer,
  metadata          jsonb,                     -- channel, recipient, etc.
  created_at        timestamptz default now()
);

-- Indexes
create index idx_flows_org on public.automation_flows (organization_id, status) where archived_at is null;
create index idx_flows_category on public.automation_flows (organization_id, category) where archived_at is null;
create index idx_execution_flow on public.automation_execution_logs (flow_id, created_at desc);
create index idx_execution_org on public.automation_execution_logs (organization_id, created_at desc);

-- RLS
alter table public.automation_flows enable row level security;
alter table public.automation_execution_logs enable row level security;

create policy "Members can read org flows"
  on public.automation_flows for select
  using (organization_id in (select public.get_user_org_ids()));

create policy "Admins+ can manage flows"
  on public.automation_flows for all
  using (public.user_has_role(organization_id, 'admin'));

create policy "Members can read execution logs"
  on public.automation_execution_logs for select
  using (organization_id in (select public.get_user_org_ids()));

-- Triggers
create trigger set_flows_updated_at
  before update on public.automation_flows
  for each row execute function public.update_updated_at();
```

### 5.9. Integrations Module

```sql
create table public.organization_integrations (
  id                uuid primary key default gen_random_uuid(),
  organization_id   uuid not null references public.organizations on delete cascade,
  integration_key   text not null,             -- e.g., 'stripe', 'xero', 'google_calendar'
  status            public.integration_status not null default 'disconnected',
  connected_as      text,                      -- e.g., 'Apex Plumbing Pty Ltd'
  access_token      text,                      -- encrypted at rest by Supabase Vault
  refresh_token     text,                      -- encrypted at rest
  token_expires_at  timestamptz,
  sync_settings     jsonb default '{}',
  account_mappings  jsonb default '{}',
  error_message     text,
  last_synced_at    timestamptz,
  created_at        timestamptz default now(),
  updated_at        timestamptz default now(),

  unique (organization_id, integration_key)
);

create table public.integration_events (
  id                   uuid primary key default gen_random_uuid(),
  organization_id      uuid not null references public.organizations on delete cascade,
  integration_id       uuid not null references public.organization_integrations on delete cascade,
  type                 text not null check (type in (
    'connected', 'disconnected', 'synced', 'error', 'configured'
  )),
  description          text,
  created_at           timestamptz default now()
);

-- Indexes
create index idx_org_integrations on public.organization_integrations (organization_id);
create index idx_org_integrations_key on public.organization_integrations (integration_key, status);
create index idx_integration_events_org on public.integration_events (organization_id, created_at desc);

-- RLS
alter table public.organization_integrations enable row level security;
alter table public.integration_events enable row level security;

create policy "Members can read org integrations"
  on public.organization_integrations for select
  using (organization_id in (select public.get_user_org_ids()));

create policy "Admins+ can manage integrations"
  on public.organization_integrations for all
  using (public.user_has_role(organization_id, 'admin'));

create policy "Members can read integration events"
  on public.integration_events for select
  using (organization_id in (select public.get_user_org_ids()));

-- Triggers
create trigger set_integrations_updated_at
  before update on public.organization_integrations
  for each row execute function public.update_updated_at();

-- Note: access_token and refresh_token should be encrypted using
-- Supabase Vault (pgsodium) in production. See Section 10.
```

---

## 6. Polar.sh Integration (Billing Module)

### 6.1. Plan Definitions

| Plan Key | Name | Polar Price ID | Limits |
|----------|------|---------------|--------|
| `free` | Free | — | 1 user, 10 jobs/mo, no automations |
| `starter_monthly` | Starter (Monthly) | `price_xxx` | 5 users, unlimited jobs, 5 automations |
| `starter_annual` | Starter (Annual) | `price_xxx` | Same as starter_monthly |
| `pro_monthly` | Pro (Monthly) | `price_xxx` | 25 users, unlimited everything, API access |
| `pro_annual` | Pro (Annual) | `price_xxx` | Same as pro_monthly |
| `business_monthly` | Business (Monthly) | `price_xxx` | Unlimited users, priority support, custom integrations |
| `business_annual` | Business (Annual) | `price_xxx` | Same as business_monthly |

### 6.2. Feature Gating Strategy

Feature gating is enforced at two levels:

1. **Database level** — RLS policies can call `get_org_plan()` to block writes on gated tables.
2. **Application level** — The frontend reads `subscriptions.plan_key` and conditionally renders UI.

```sql
-- Example: Gate automations to paid plans
create policy "Paid plans can create automations"
  on public.automation_flows for insert
  with check (
    public.get_org_plan(organization_id) in (
      'starter_monthly', 'starter_annual',
      'pro_monthly', 'pro_annual',
      'business_monthly', 'business_annual'
    )
  );
```

### 6.3. Checkout Flow

```
┌──────────┐    POST /create-checkout     ┌───────────────┐
│ Frontend │ ──────────────────────────▶  │ Edge Function  │
│          │                              │                │
│          │    { redirect_url }          │  Polar API:    │
│          │ ◀──────────────────────────  │  createCheckout│
│          │                              └───────────────┘
│          │    Redirect to Polar
│          │ ──────────────────────────▶  Polar Hosted Checkout
│          │
│          │    Redirect back
│          │ ◀──────────────────────────  /dashboard?checkout=success
└──────────┘
```

**Edge Function: `create-checkout`**

```typescript
// supabase/functions/create-checkout/index.ts
import { serve } from "https://deno.land/std@0.177.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

serve(async (req) => {
  const { organization_id, price_id, success_url, cancel_url } = await req.json();

  // Verify the requesting user is an admin/owner of the org
  const supabase = createClient(
    Deno.env.get("SUPABASE_URL")!,
    Deno.env.get("SUPABASE_ANON_KEY")!,
    { global: { headers: { Authorization: req.headers.get("Authorization")! } } }
  );

  const { data: member } = await supabase
    .from("organization_members")
    .select("role")
    .eq("organization_id", organization_id)
    .eq("user_id", (await supabase.auth.getUser()).data.user?.id)
    .single();

  if (!member || !["owner", "admin"].includes(member.role)) {
    return new Response(JSON.stringify({ error: "Unauthorized" }), { status: 403 });
  }

  // Get or create Polar customer
  const { data: org } = await supabase
    .from("organizations")
    .select("polar_customer_id, name, slug")
    .eq("id", organization_id)
    .single();

  let polar_customer_id = org?.polar_customer_id;

  if (!polar_customer_id) {
    const customerRes = await fetch("https://api.polar.sh/v1/customers", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${Deno.env.get("POLAR_ACCESS_TOKEN")}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        name: org?.name,
        metadata: { organization_id, slug: org?.slug },
      }),
    });
    const customer = await customerRes.json();
    polar_customer_id = customer.id;

    // Save customer ID back to org
    const adminClient = createClient(
      Deno.env.get("SUPABASE_URL")!,
      Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!
    );
    await adminClient
      .from("organizations")
      .update({ polar_customer_id })
      .eq("id", organization_id);
  }

  // Create checkout session
  const checkoutRes = await fetch("https://api.polar.sh/v1/checkouts", {
    method: "POST",
    headers: {
      Authorization: `Bearer ${Deno.env.get("POLAR_ACCESS_TOKEN")}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      product_price_id: price_id,
      customer_id: polar_customer_id,
      success_url: success_url || `${Deno.env.get("APP_URL")}/dashboard?checkout=success`,
      metadata: { organization_id },
    }),
  });

  const checkout = await checkoutRes.json();

  return new Response(JSON.stringify({ url: checkout.url }), {
    headers: { "Content-Type": "application/json" },
  });
});
```

### 6.4. Webhook Processing

**Edge Function: `polar-webhook`**

| Polar Event | Action |
|-------------|--------|
| `subscription.created` | Insert into `subscriptions`, log to `audit_log` |
| `subscription.updated` | Update `status`, `current_period_end`, `cancel_at_period_end` |
| `subscription.revoked` | Set `status = 'canceled'`, set `canceled_at` |
| `checkout.completed` | (Handled by subscription.created — no separate action needed) |
| `customer.updated` | Update `organizations.polar_customer_id` if changed |

```typescript
// supabase/functions/polar-webhook/index.ts
import { serve } from "https://deno.land/std@0.177.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { createHmac } from "https://deno.land/std@0.177.0/crypto/mod.ts";

serve(async (req) => {
  // 1. Verify webhook signature
  const body = await req.text();
  const signature = req.headers.get("x-polar-signature");
  const secret = Deno.env.get("POLAR_WEBHOOK_SECRET")!;

  const expected = createHmac("sha256", secret).update(body).digest("hex");
  if (signature !== expected) {
    return new Response("Invalid signature", { status: 401 });
  }

  const event = JSON.parse(body);
  const supabase = createClient(
    Deno.env.get("SUPABASE_URL")!,
    Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!  // service_role to bypass RLS
  );

  // 2. Route by event type
  switch (event.type) {
    case "subscription.created": {
      const sub = event.data;
      const org_id = sub.metadata?.organization_id;
      if (!org_id) break;

      await supabase.from("subscriptions").upsert({
        organization_id: org_id,
        polar_subscription_id: sub.id,
        polar_product_id: sub.product_id,
        plan_key: sub.metadata?.plan_key || sub.product?.name?.toLowerCase().replace(/\s+/g, "_"),
        status: sub.status === "active" ? "active" : "incomplete",
        current_period_start: sub.current_period_start,
        current_period_end: sub.current_period_end,
        cancel_at_period_end: sub.cancel_at_period_end || false,
      }, { onConflict: "polar_subscription_id" });

      await supabase.from("audit_log").insert({
        organization_id: org_id,
        action: "subscription.created",
        entity_type: "subscription",
        entity_id: sub.id,
        new_data: sub,
      });
      break;
    }

    case "subscription.updated": {
      const sub = event.data;
      const org_id = sub.metadata?.organization_id;

      await supabase
        .from("subscriptions")
        .update({
          status: sub.status,
          plan_key: sub.metadata?.plan_key || sub.product?.name?.toLowerCase().replace(/\s+/g, "_"),
          current_period_start: sub.current_period_start,
          current_period_end: sub.current_period_end,
          cancel_at_period_end: sub.cancel_at_period_end || false,
        })
        .eq("polar_subscription_id", sub.id);

      if (org_id) {
        await supabase.from("audit_log").insert({
          organization_id: org_id,
          action: "subscription.updated",
          entity_type: "subscription",
          entity_id: sub.id,
          new_data: { status: sub.status, period_end: sub.current_period_end },
        });
      }
      break;
    }

    case "subscription.revoked": {
      const sub = event.data;
      await supabase
        .from("subscriptions")
        .update({ status: "canceled", canceled_at: new Date().toISOString() })
        .eq("polar_subscription_id", sub.id);
      break;
    }
  }

  return new Response(JSON.stringify({ received: true }), { status: 200 });
});
```

### 6.5. Customer Portal

**Edge Function: `portal-link`**

Generates a link to the Polar Customer Portal where users can update payment methods, view invoices, and manage their subscription.

```typescript
// supabase/functions/portal-link/index.ts
serve(async (req) => {
  const { organization_id } = await req.json();

  // Verify user is admin/owner (same auth check as create-checkout)
  // ...

  const { data: org } = await supabase
    .from("organizations")
    .select("polar_customer_id")
    .eq("id", organization_id)
    .single();

  if (!org?.polar_customer_id) {
    return new Response(JSON.stringify({ error: "No billing account" }), { status: 404 });
  }

  const portalRes = await fetch(
    `https://api.polar.sh/v1/customers/${org.polar_customer_id}/portal`,
    {
      method: "POST",
      headers: {
        Authorization: `Bearer ${Deno.env.get("POLAR_ACCESS_TOKEN")}`,
        "Content-Type": "application/json",
      },
    }
  );

  const portal = await portalRes.json();
  return new Response(JSON.stringify({ url: portal.url }));
});
```

---

## 7. Cron Jobs & Automations

### 7.1. Infrastructure

- **Tool:** `pg_cron` (native Supabase database extension)
- **HTTP calls:** `pg_net` for invoking Edge Functions from within SQL
- **Monitoring:** Failed crons log to `audit_log` with `action = 'cron.failed'`

### 7.2. Core Cron Jobs

| # | Job Name | Schedule | Action | Details |
|---|----------|----------|--------|---------|
| 1 | Daily Digest | `0 8 * * *` (8 AM UTC) | Edge Function: `trigger-daily-emails` | Loops through active orgs, aggregates "Jobs for Today" and overdue invoices, sends via Resend. |
| 2 | Subscription Sync Audit | `0 0 * * 0` (Weekly, midnight Sunday) | Edge Function: `sync-polar-status` | Verifies local subscription status matches Polar API. Fixes drift caused by missed webhooks. |
| 3 | Stale Invite Cleanup | `0 3 * * *` (3 AM UTC daily) | SQL | `DELETE FROM organization_invites WHERE status = 'pending' AND expires_at < now()` |
| 4 | Overdue Invoice Sweep | `0 7 * * *` (7 AM UTC daily) | SQL + Edge Function | Sets `status = 'overdue'` on invoices past `due_date` that are still `sent`. Optionally triggers reminder email. |
| 5 | Asset Service Reminders | `0 6 * * 1` (6 AM Monday) | Edge Function: `asset-service-reminder` | Finds assets where `next_service_date` is within 14 days, creates inbox item for org managers. |
| 6 | Form Expiry | `0 4 * * *` (4 AM UTC daily) | SQL | `UPDATE form_submissions SET status = 'expired' WHERE status = 'pending' AND expires_at < now()` |
| 7 | Automation Engine Tick | `*/5 * * * *` (Every 5 min) | Edge Function: `run-automations` | Checks for active flows with pending delay blocks that have elapsed. Executes the next action in the flow. |

### 7.3. SQL Setup

```sql
-- Enable extensions
create extension if not exists pg_cron;
create extension if not exists pg_net;

-- 1. Daily Digest
select cron.schedule(
  'daily-digest',
  '0 8 * * *',
  $$select net.http_post(
    url := current_setting('app.settings.supabase_url') || '/functions/v1/trigger-daily-emails',
    headers := jsonb_build_object(
      'Authorization', 'Bearer ' || current_setting('app.settings.service_role_key'),
      'Content-Type', 'application/json'
    ),
    body := '{}'::jsonb
  )$$
);

-- 2. Subscription Sync
select cron.schedule(
  'subscription-sync',
  '0 0 * * 0',
  $$select net.http_post(
    url := current_setting('app.settings.supabase_url') || '/functions/v1/sync-polar-status',
    headers := jsonb_build_object(
      'Authorization', 'Bearer ' || current_setting('app.settings.service_role_key'),
      'Content-Type', 'application/json'
    ),
    body := '{}'::jsonb
  )$$
);

-- 3. Stale Invite Cleanup
select cron.schedule(
  'stale-invite-cleanup',
  '0 3 * * *',
  $$delete from public.organization_invites
    where status = 'pending' and expires_at < now()$$
);

-- 4. Overdue Invoice Sweep
select cron.schedule(
  'overdue-invoice-sweep',
  '0 7 * * *',
  $$update public.invoices
    set status = 'overdue', updated_at = now()
    where status = 'sent'
      and due_date < current_date
      and archived_at is null$$
);

-- 5. Form Expiry
select cron.schedule(
  'form-submission-expiry',
  '0 4 * * *',
  $$update public.form_submissions
    set status = 'expired'
    where status = 'pending'
      and expires_at < now()$$
);
```

---

## 8. API & Edge Functions (Endpoints)

### 8.1. Function Registry

| Function Name | Method | Auth | Purpose |
|---------------|--------|------|---------|
| `create-checkout` | POST | User (admin+) | Generates Polar checkout link for a specific org |
| `polar-webhook` | POST | Polar signature | Receives and processes billing events |
| `portal-link` | POST | User (admin+) | Generates Polar Customer Portal URL |
| `invite-member` | POST | User (admin+) | Sends transactional invite email via Resend |
| `accept-invite` | POST | User (any) | Accepts an invite token, adds user to org |
| `trigger-daily-emails` | POST | Service role | Cron-triggered: sends daily digest emails |
| `sync-polar-status` | POST | Service role | Cron-triggered: audits subscription state |
| `asset-service-reminder` | POST | Service role | Cron-triggered: sends service reminders |
| `run-automations` | POST | Service role | Cron-triggered: processes automation delays |
| `ai-process` | POST | User | Generic endpoint for AI modules (future) |

### 8.2. Endpoint Specifications

#### `POST /invite-member`

**Request:**
```json
{
  "organization_id": "uuid",
  "email": "new_user@example.com",
  "role": "technician"
}
```

**Logic:**
1. Verify caller is admin+ in the organization.
2. Check no existing active member with that email.
3. Check no pending invite with that email (or update the existing one).
4. Insert into `organization_invites`.
5. Send email via Resend with invite link: `{APP_URL}/auth?invite={token}`.
6. Log to `audit_log`.

**Response:**
```json
{
  "success": true,
  "invite_id": "uuid",
  "expires_at": "2026-02-22T00:00:00Z"
}
```

#### `POST /accept-invite`

**Request:**
```json
{
  "token": "hex_token_string"
}
```

**Logic:**
1. Look up invite by token where `status = 'pending'` and `expires_at > now()`.
2. If not found or expired, return 404.
3. Add the authenticated user to `organization_members` with the invite's role.
4. Update invite `status = 'accepted'`.
5. If user has no `onboarding_completed`, mark it true.
6. Log to `audit_log`.

**Response:**
```json
{
  "success": true,
  "organization_id": "uuid",
  "organization_name": "Apex Plumbing",
  "role": "technician"
}
```

---

## 9. File Storage

### 9.1. Buckets

| Bucket | Access | Purpose |
|--------|--------|---------|
| `avatars` | Public (read) | User profile photos |
| `org-logos` | Public (read) | Organization logos |
| `job-photos` | Private | Photos attached to job activity |
| `form-attachments` | Private | Photo evidence, signature images from form submissions |
| `asset-images` | Private | Asset/vehicle photos |

### 9.2. Storage Policies

```sql
-- Avatars: users can upload their own
create policy "Users can upload own avatar"
  on storage.objects for insert
  with check (
    bucket_id = 'avatars'
    and (storage.foldername(name))[1] = auth.uid()::text
  );

-- Job photos: org members can upload
create policy "Org members can upload job photos"
  on storage.objects for insert
  with check (
    bucket_id = 'job-photos'
    and (storage.foldername(name))[1] in (
      select id::text from public.organizations
      where id in (select public.get_user_org_ids())
    )
  );

-- Private buckets: org members can read
create policy "Org members can read org files"
  on storage.objects for select
  using (
    bucket_id in ('job-photos', 'form-attachments', 'asset-images')
    and (storage.foldername(name))[1] in (
      select id::text from public.organizations
      where id in (select public.get_user_org_ids())
    )
  );
```

### 9.3. File Path Convention

All private files follow the pattern:

```
{bucket}/{organization_id}/{entity_type}/{entity_id}/{filename}
```

Example: `job-photos/abc-123/jobs/JOB-401/photo_01.jpg`

---

## 10. Security Considerations

### 10.1. Secrets Management

| Secret | Location | Purpose |
|--------|----------|---------|
| `SUPABASE_URL` | Edge Function env | Supabase project URL |
| `SUPABASE_ANON_KEY` | Edge Function env + Client | Public anon key |
| `SUPABASE_SERVICE_ROLE_KEY` | Edge Function env only | Bypasses RLS for server operations |
| `POLAR_ACCESS_TOKEN` | Edge Function env | Polar API authentication |
| `POLAR_WEBHOOK_SECRET` | Edge Function env | Webhook signature verification |
| `RESEND_API_KEY` | Edge Function env | Transactional email sending |
| `APP_URL` | Edge Function env | Frontend URL for redirects |

### 10.2. Token Encryption

Integration OAuth tokens (`access_token`, `refresh_token` in `organization_integrations`) must be encrypted at rest using Supabase Vault (pgsodium):

```sql
-- Enable vault
create extension if not exists pgsodium;

-- Create encryption key
select vault.create_secret('integration_encryption_key', gen_random_bytes(32)::text);

-- Encrypt on write, decrypt on read via views or functions
```

### 10.3. Rate Limiting

Edge Functions enforce rate limits at the function level:

| Endpoint | Limit | Window |
|----------|-------|--------|
| `create-checkout` | 10 requests | per minute per org |
| `invite-member` | 20 requests | per hour per org |
| `accept-invite` | 5 requests | per minute per user |
| `polar-webhook` | 100 requests | per minute (Polar sends bursts) |
| `ai-process` | 30 requests | per minute per org |

### 10.4. CORS

Edge Functions only accept requests from:
- `https://app.iworkr.com`
- `https://*.iworkr.com`
- `http://localhost:3000` (development only)

---

## 11. Realtime Subscriptions

### 11.1. Enabled Tables

| Table | Channel Filter | UI Consumer |
|-------|---------------|-------------|
| `inbox_items` | `organization_id=eq.{org_id}` | Inbox, Dashboard inbox widget, notification bell |
| `jobs` | `organization_id=eq.{org_id}` | Jobs list, Dashboard jobs widget |
| `schedule_blocks` | `organization_id=eq.{org_id}` | Schedule, Live Dispatch radar |
| `invoices` | `organization_id=eq.{org_id}` | Finance module |

### 11.2. Client Subscription Pattern

```typescript
// Example: Subscribe to schedule changes for live dispatch
const channel = supabase
  .channel("schedule-live")
  .on(
    "postgres_changes",
    {
      event: "*",
      schema: "public",
      table: "schedule_blocks",
      filter: `organization_id=eq.${orgId}`,
    },
    (payload) => {
      // Update Zustand store
      scheduleStore.handleRealtimeEvent(payload);
    }
  )
  .subscribe();
```

---

## 12. Onboarding Flow (Backend)

The onboarding flow creates backend resources as the user progresses through setup:

| Step | Backend Action |
|------|---------------|
| **Auth** | Supabase Auth creates `auth.users` row → trigger creates `profiles` row |
| **Identity** | Edge Function: creates `organizations` row + `organization_members` row (role: owner) |
| **Trade** | Updates `organizations.trade` |
| **Team** | Creates `organization_invites` rows, triggers invite emails |
| **Training** | No backend action (client-side only) |
| **Integrations** | Creates `organization_integrations` rows with `status = 'disconnected'` |
| **Complete** | Updates `profiles.onboarding_completed = true` |

---

## 13. Migration Strategy

### 13.1. Migration Files

Migrations are ordered and idempotent. Each file lives in `supabase/migrations/`:

```
supabase/migrations/
├── 001_extensions.sql                 # pg_cron, pg_net, pgsodium
├── 002_enums.sql                      # All custom types
├── 003_core_profiles.sql              # profiles table + trigger
├── 004_core_organizations.sql         # organizations + members + invites
├── 005_core_subscriptions.sql         # subscriptions table
├── 006_core_audit_log.sql             # audit_log table
├── 007_core_rls_helpers.sql           # Helper functions
├── 008_core_rls_policies.sql          # Core RLS policies
├── 010_module_inbox.sql               # Inbox module
├── 011_module_jobs.sql                # Jobs module
├── 012_module_clients.sql             # Clients module
├── 013_module_schedule.sql            # Schedule module
├── 014_module_finance.sql             # Finance module
├── 015_module_assets.sql              # Assets module
├── 016_module_forms.sql               # Forms module
├── 017_module_automations.sql         # Automations module
├── 018_module_integrations.sql        # Integrations module
├── 020_cron_jobs.sql                  # pg_cron schedules
├── 021_storage_buckets.sql            # Storage bucket creation
├── 022_storage_policies.sql           # Storage RLS policies
└── 030_seed_data.sql                  # Development seed data
```

### 13.2. Seed Data

Development environments are seeded with the same mock data currently in the frontend `*-data.ts` files, mapped to the Postgres schema. The seed creates:

- 1 organization ("Apex Plumbing", slug: `apex-plumbing`)
- 4 team members with roles
- 10 jobs across all statuses
- 7 clients
- 9 invoices
- 12 schedule blocks
- Sample assets, forms, automations, and integrations

---

## 14. Environment Configuration

### 14.1. Required Environment Variables

```bash
# Supabase
NEXT_PUBLIC_SUPABASE_URL=https://xxx.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJ...
SUPABASE_SERVICE_ROLE_KEY=eyJ...        # Server only, never exposed to client

# Polar.sh
POLAR_ACCESS_TOKEN=pat_xxx
POLAR_WEBHOOK_SECRET=whsec_xxx
POLAR_ORGANIZATION_ID=org_xxx           # Your Polar org (not iWorkr org)

# Email
RESEND_API_KEY=re_xxx
RESEND_FROM_EMAIL=notifications@iworkr.com

# App
NEXT_PUBLIC_APP_URL=https://app.iworkr.com
```

### 14.2. Supabase Project Settings

```
Auth → Providers → Google: Enabled
Auth → URL Configuration → Redirect URLs: https://app.iworkr.com/**
Auth → Email Templates: Customized with iWorkr branding
Database → Extensions: pg_cron ✓, pg_net ✓, pgsodium ✓
Realtime → Enabled tables: inbox_items, jobs, schedule_blocks, invoices
```

---

## 15. Testing Strategy

### 15.1. Database Tests

- **RLS Policy Tests:** For every table, verify:
  - Authenticated user in org A cannot read org B data
  - Unauthenticated requests return zero rows
  - Role-gated operations fail for insufficient roles
- **Trigger Tests:** Profile auto-creation, invoice total recalculation
- **Function Tests:** `get_user_org_ids()`, `user_has_role()`, `org_has_active_subscription()`

### 15.2. Edge Function Tests

- **Webhook Tests:** Send simulated Polar events, verify database state
- **Auth Tests:** Verify unauthorized users cannot call admin endpoints
- **Invite Flow:** End-to-end: create invite → send email → accept → verify membership

### 15.3. Integration Tests

- **Checkout Flow:** Mock Polar API, verify redirect and subscription creation
- **Realtime:** Verify schedule_blocks changes propagate to subscribed clients
- **Cron:** Verify overdue invoice sweep correctly transitions statuses

---

## 16. Monitoring & Observability

| Metric | Source | Alert Threshold |
|--------|--------|----------------|
| Webhook processing latency | Edge Function logs | > 5s |
| Failed webhook events | `audit_log` where action = 'webhook.failed' | Any |
| Subscription status drift | Weekly sync audit | Any mismatch |
| RLS policy denials | Postgres logs | Unexpected spikes |
| Edge Function errors | Supabase Dashboard | Error rate > 1% |
| Database connection pool | Supabase metrics | > 80% utilization |
| Storage usage | Supabase Dashboard | > 80% of plan limit |

---

## 17. Next Steps

### Phase 1: Foundation (Week 1-2)

1. Initialize Supabase project, enable `pg_cron`, `pg_net`, and `pgsodium` extensions.
2. Apply core migrations: `001` through `008` (profiles, orgs, members, subscriptions, audit, RLS).
3. Deploy Edge Functions: `invite-member`, `accept-invite`.
4. Connect Supabase Auth: Google OAuth + Magic Link.
5. Integrate `supabase-js` into Next.js frontend, replace Zustand mock data for auth/profile.

### Phase 2: Billing (Week 3)

1. Register Polar.sh account, create Products & Prices.
2. Deploy Edge Functions: `create-checkout`, `polar-webhook`, `portal-link`.
3. Configure Polar webhooks to point to Supabase Edge Function URL.
4. Build Settings → Billing page with real subscription data.

### Phase 3: Module Migrations (Week 4-5)

1. Apply module migrations: `010` through `018` (all modules).
2. Replace frontend mock data stores with Supabase queries (one module at a time).
3. Enable Realtime on `inbox_items`, `jobs`, `schedule_blocks`.
4. Set up Storage buckets and policies.

### Phase 4: Automations & Cron (Week 6)

1. Apply cron migration: `020`.
2. Deploy cron Edge Functions: `trigger-daily-emails`, `sync-polar-status`, `run-automations`.
3. Configure Resend for transactional emails.
4. End-to-end test all cron jobs.

### Phase 5: Hardening (Week 7-8)

1. Write and run RLS policy test suite.
2. Set up monitoring dashboards and alerts.
3. Load test with simulated multi-tenant data.
4. Security audit: token encryption, rate limiting, CORS.
5. Seed data migration for demo/staging environments.

---

## Appendix A: Table Reference

| Table | Module | Realtime | Soft Delete |
|-------|--------|----------|-------------|
| `profiles` | Core | No | No |
| `organizations` | Core | No | No |
| `organization_members` | Core | No | No |
| `organization_invites` | Core | No | Hard delete (cron) |
| `subscriptions` | Core | No | No |
| `audit_log` | Core | No | No |
| `inbox_items` | Inbox | Yes | Hard delete (archive flag) |
| `jobs` | Jobs | Yes | `archived_at` |
| `job_subtasks` | Jobs | No | Cascade |
| `job_activity` | Jobs | No | No |
| `clients` | Clients | No | `archived_at` |
| `client_contacts` | Clients | No | Cascade |
| `client_activity` | Clients | No | No |
| `schedule_blocks` | Schedule | Yes | No |
| `invoices` | Finance | Yes | `archived_at` |
| `invoice_line_items` | Finance | No | Cascade |
| `invoice_events` | Finance | No | No |
| `payouts` | Finance | No | No |
| `assets` | Assets | No | `archived_at` |
| `stock_items` | Assets | No | No |
| `asset_audit_log` | Assets | No | No |
| `form_templates` | Forms | No | `archived_at` |
| `form_submissions` | Forms | No | No |
| `automation_flows` | Automations | No | `archived_at` |
| `automation_execution_logs` | Automations | No | No |
| `organization_integrations` | Integrations | No | No |
| `integration_events` | Integrations | No | No |

## Appendix B: Role Permission Matrix

| Role | Jobs | Clients | Finance | Schedule | Assets | Forms | Team | Settings | Integrations |
|------|------|---------|---------|----------|--------|-------|------|----------|--------------|
| **owner** | VCUDE | VCUDE | VCUDE | VCUDE | VCUDE | VCUDE | VCUDE | VCUDE | VCUDE |
| **admin** | VCUDE | VCUDE | VCUDE | VCUDE | VCUDE | VCUDE | VCUE | VCUE | VCUDE |
| **manager** | VCUE | VCUE | VCE | VCUE | VCUE | VCUE | VUE | V | VE |
| **senior_tech** | VCUE | VCE | V | VUE | VUE | VCUE | V | — | — |
| **technician** | VUE | V | V | VU | V | VCU | V | — | — |
| **apprentice** | V | V | — | V | V | VC | V | — | — |
| **subcontractor** | VU | V | V | V | — | VC | — | — | — |
| **office_admin** | VCUE | VCUE | VCUE | VCE | V | VCUE | V | V | V |

*V = View, C = Create, U = Update/Edit, D = Delete, E = Export*

---

*This PRD defines the backend infrastructure for iWorkr and should be read alongside the [Frontend PRD](./PRD.md) for full system context.*
